\documentclass[../SWD_disp.tex]{subfiles}

\begin{document}
\section{Observer Pattern}

Giv definitionen af et design pattern til at starte med.

\subsection{Opbygning af Observer Pattern}
Observer Pattern er i gruppen af behavioral patterns, fordi den denfinerer måden for kommunkationen mellem klasserne.


Det tillate et enkelt object kendt som ``subject'' til, at publiserer ændringer i dens state. En eller mange observer objekter der afhænger af subjects, kan subscribe til et, således at de automatisk bliver notificeret.


Observer Pattern giver lav koblint mellem subjects og observers


Subject (data der ændres) og Observer (data der skal hentes fra Subject)
\begin{itemize}
    \item observeren skal kunne tilføjes (attached) til subject uden, at ændre implementeringsmæssigt for subject (OCP)
    \item Tillade provideren til at notificere observers ved data ændring (lav kobling)
    \item Tillade mange observers til, at blive informeret på opdatering af den samme data.
    \item Se efter 1-many afhængigheder således, at når det ene object ændrer state, til dens afhængige blive notificeret og opdateret automatisk.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics{observer_pattern.PNG}
    \caption{Observer Pattern}
    \label{fig:observer_pattern}
\end{figure}

At anvende SOLID principper, fremmer godt software design. At følge OCP betyder at du får lav kobling mellem dine klasser. Dette resultere yderemere i software som er let at teste.

\subsection*{Fordele}
\begin{itemize}
    \item Skaber lav kobling mellem Subject og Observer objekter.
    \item Tillader ét subject at opdateren x antal observers automatisk. 
    \item Ingen behov for, at modificerer på Subject ved tilføjelse af nye observers. Dette er pga. OCP.
    \item Tilføje og fjerne eksisterende observers til enhver tid.
\end{itemize}

\subsection*{Ulemper}
\begin{itemize}
    \item Rækkefølgen af notifications af observers kan være uafhængig.
    \item Memoryleak kan forekomme i ikke Garbage-Collection sprog pga. du explicit skal attach og detach Subject.
    \item tilføjer en kompleksitet som ikke altid er nødvendig.
\end{itemize}
\subsection{Push vs Pull Observer}
Når du har klaret opsætningen med observer, så skal der tages endnu et valg. Vil du kører med en push observer eller en pull observer?
\subsubsection{Push}
Dette handler om at dit subject ``pusher'' sine ændringer. På denne måde får man en kopi eller reference af hele subject. Dette er smart hvis dit subject er lille eller du skal bruge alt info i dit subject. Der kan opstå problemer ved dette hvis du kun skal bruge en meget lille del af dit subject. I dette tilfælde kan det være crazy at modtage hele subject.    
\subsubsection{Pull}
Derfor kan man benytte pull. Der får man som observer bare besked på at der er en opdatering. Så ved observer at nu er der data som er nyt, og kan hente det data som er nødvendigt eller ønsket. 


% \subsection*{Forskellige varianter af GoF Observer}
% \subsubsection*{Subject af samme type}
% \begin{figure}[H]
%     \centering
%     \includegraphics[scale = 1.5]{subject_same_type.PNG}
%     \caption{Subject Same Type}
%     \label{fig:subject_same_type}
% \end{figure}


% \subsubsection*{Ved samme type implementering}
% \begin{figure}[H]
%     \centering
%     \includegraphics{same_type_impl.PNG}
%     \caption{Samme Type Implementering}
%     \label{fig:same_type_impl}
% \end{figure}

% \subsubsection*{Ved håndtering af subjekt af forskellige typer:}
% \begin{figure}[H]
%     \centering
%     \includegraphics{subject_different_type.PNG}
%     \caption{Subject af forskellige typer}
%     \label{fig:subject_diff_type}
% \end{figure}
\end{document}
